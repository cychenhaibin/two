#include<stdio.h>
#define MAX 66 //50的阶乘为65位，B存的是每一个数的阶乘
//一位数+一位数不会超过两位数 如9+9=18，两位数加两位数不会超过3位数。即相加和最大位数取决于加数的最大位数+1
//所以由此可得，1！+2！位数不会超过2！的位数，依次类推下去。
//阶乘和的最大位数取决于最大阶乘位数+1 此处即50！ 的位数+1。当然，小数据阶乘和的位数不算多，这样精算其实节省不了什么时间，可尽量将数组开大点。
int main()
{
    int i, A[MAX+1] = { 0 }, B[MAX+1] = { 0 }, n, j;
    scanf("%d", &n);
    A[0] = B[0] = 1;//反正都是从1开始，A是用来存阶乘之和，B是用来存每次的i的阶乘 
    for (i = 2; i <= n; i++) {
        for (j = 0; j < MAX; j++)
            B[j] *= i;//利用 n！=n*（n-1）！，B用来存每一次i的阶乘 ,B的每一位都要和i相乘 模拟乘法 
        for (j = 0; j < MAX; j++)//模拟进位
            if (B[j] > 9) {
                B[j + 1] += B[j] / 10;
                B[j] %= 10;
            }
        for (j = 0; j < MAX; j++) {//A来存每次的阶乘相加  高精度加法 
            A[j] += B[j];
            if (A[j] > 9) {
                A[j + 1] += A[j] / 10;
                A[j] %= 10;
            }
        }
    }
    for (i = MAX; i >= 0 && A[i] == 0; i--);//去除前导0 
    for (j = i; j >= 0; j--) printf("%d", A[j]);
    return 0;
}
